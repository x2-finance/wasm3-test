/* automatically generated by rust-bindgen 0.59.2 */

pub const M3_VERSION_MAJOR: u32 = 0;
pub const M3_VERSION_MINOR: u32 = 5;
pub const M3_VERSION_REV: u32 = 0;
pub const M3_VERSION: &[u8; 6usize] = b"0.5.0\0";
pub const M3_COMPILER_CLANG: u32 = 1;
pub const M3_ARCH: &[u8; 7usize] = b"x86_64\0";
pub type size_t = cty::c_ulong;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_long;
pub type __uint64_t = cty::c_ulong;
pub type va_list = __builtin_va_list;
pub type M3Result = *const cty::c_char;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3Environment {
    _unused: [u8; 0],
}
pub type IM3Environment = *mut M3Environment;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3Runtime {
    _unused: [u8; 0],
}
pub type IM3Runtime = *mut M3Runtime;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3Module {
    _unused: [u8; 0],
}
pub type IM3Module = *mut M3Module;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3Function {
    _unused: [u8; 0],
}
pub type IM3Function = *mut M3Function;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3Global {
    _unused: [u8; 0],
}
pub type IM3Global = *mut M3Global;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3ErrorInfo {
    pub result: M3Result,
    pub runtime: IM3Runtime,
    pub module: IM3Module,
    pub function: IM3Function,
    pub file: *const cty::c_char,
    pub line: u32,
    pub message: *const cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3BacktraceFrame {
    pub moduleOffset: u32,
    pub function: IM3Function,
    pub next: *mut M3BacktraceFrame,
}
pub type IM3BacktraceFrame = *mut M3BacktraceFrame;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3BacktraceInfo {
    pub frames: IM3BacktraceFrame,
    pub lastFrame: IM3BacktraceFrame,
}
pub type IM3BacktraceInfo = *mut M3BacktraceInfo;
pub mod M3ValueType {
    pub type Type = cty::c_uint;
    pub const c_m3Type_none: Type = 0;
    pub const c_m3Type_i32: Type = 1;
    pub const c_m3Type_i64: Type = 2;
    pub const c_m3Type_f32: Type = 3;
    pub const c_m3Type_f64: Type = 4;
    pub const c_m3Type_unknown: Type = 5;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3TaggedValue {
    pub type_: M3ValueType::Type,
    pub value: M3TaggedValue_M3ValueUnion,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M3TaggedValue_M3ValueUnion {
    pub i32_: u32,
    pub i64_: u64,
    pub f32_: f32,
    pub f64_: f64,
}
pub type IM3TaggedValue = *mut M3TaggedValue;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3ImportInfo {
    pub moduleUtf8: *const cty::c_char,
    pub fieldUtf8: *const cty::c_char,
}
pub type IM3ImportInfo = *mut M3ImportInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3ImportContext {
    pub userdata: *mut cty::c_void,
    pub function: IM3Function,
}
pub type IM3ImportContext = *mut M3ImportContext;
extern "C" {
    pub static mut m3Err_none: M3Result;
}
extern "C" {
    pub static mut m3Err_mallocFailed: M3Result;
}
extern "C" {
    pub static mut m3Err_incompatibleWasmVersion: M3Result;
}
extern "C" {
    pub static mut m3Err_wasmMalformed: M3Result;
}
extern "C" {
    pub static mut m3Err_misorderedWasmSection: M3Result;
}
extern "C" {
    pub static mut m3Err_wasmUnderrun: M3Result;
}
extern "C" {
    pub static mut m3Err_wasmOverrun: M3Result;
}
extern "C" {
    pub static mut m3Err_wasmMissingInitExpr: M3Result;
}
extern "C" {
    pub static mut m3Err_lebOverflow: M3Result;
}
extern "C" {
    pub static mut m3Err_missingUTF8: M3Result;
}
extern "C" {
    pub static mut m3Err_wasmSectionUnderrun: M3Result;
}
extern "C" {
    pub static mut m3Err_wasmSectionOverrun: M3Result;
}
extern "C" {
    pub static mut m3Err_invalidTypeId: M3Result;
}
extern "C" {
    pub static mut m3Err_tooManyMemorySections: M3Result;
}
extern "C" {
    pub static mut m3Err_tooManyArgsRets: M3Result;
}
extern "C" {
    pub static mut m3Err_moduleAlreadyLinked: M3Result;
}
extern "C" {
    pub static mut m3Err_functionLookupFailed: M3Result;
}
extern "C" {
    pub static mut m3Err_functionImportMissing: M3Result;
}
extern "C" {
    pub static mut m3Err_malformedFunctionSignature: M3Result;
}
extern "C" {
    pub static mut m3Err_noCompiler: M3Result;
}
extern "C" {
    pub static mut m3Err_unknownOpcode: M3Result;
}
extern "C" {
    pub static mut m3Err_restictedOpcode: M3Result;
}
extern "C" {
    pub static mut m3Err_functionStackOverflow: M3Result;
}
extern "C" {
    pub static mut m3Err_functionStackUnderrun: M3Result;
}
extern "C" {
    pub static mut m3Err_mallocFailedCodePage: M3Result;
}
extern "C" {
    pub static mut m3Err_settingImmutableGlobal: M3Result;
}
extern "C" {
    pub static mut m3Err_typeMismatch: M3Result;
}
extern "C" {
    pub static mut m3Err_typeCountMismatch: M3Result;
}
extern "C" {
    pub static mut m3Err_missingCompiledCode: M3Result;
}
extern "C" {
    pub static mut m3Err_wasmMemoryOverflow: M3Result;
}
extern "C" {
    pub static mut m3Err_globalMemoryNotAllocated: M3Result;
}
extern "C" {
    pub static mut m3Err_globaIndexOutOfBounds: M3Result;
}
extern "C" {
    pub static mut m3Err_argumentCountMismatch: M3Result;
}
extern "C" {
    pub static mut m3Err_argumentTypeMismatch: M3Result;
}
extern "C" {
    pub static mut m3Err_globalLookupFailed: M3Result;
}
extern "C" {
    pub static mut m3Err_globalTypeMismatch: M3Result;
}
extern "C" {
    pub static mut m3Err_globalNotMutable: M3Result;
}
extern "C" {
    pub static mut m3Err_trapOutOfBoundsMemoryAccess: M3Result;
}
extern "C" {
    pub static mut m3Err_trapDivisionByZero: M3Result;
}
extern "C" {
    pub static mut m3Err_trapIntegerOverflow: M3Result;
}
extern "C" {
    pub static mut m3Err_trapIntegerConversion: M3Result;
}
extern "C" {
    pub static mut m3Err_trapIndirectCallTypeMismatch: M3Result;
}
extern "C" {
    pub static mut m3Err_trapTableIndexOutOfRange: M3Result;
}
extern "C" {
    pub static mut m3Err_trapTableElementIsNull: M3Result;
}
extern "C" {
    pub static mut m3Err_trapExit: M3Result;
}
extern "C" {
    pub static mut m3Err_trapAbort: M3Result;
}
extern "C" {
    pub static mut m3Err_trapUnreachable: M3Result;
}
extern "C" {
    pub static mut m3Err_trapStackOverflow: M3Result;
}
extern "C" {
    pub fn m3_NewEnvironment() -> IM3Environment;
}
extern "C" {
    pub fn m3_FreeEnvironment(i_environment: IM3Environment);
}
extern "C" {
    pub fn m3_NewRuntime(
        io_environment: IM3Environment,
        i_stackSizeInBytes: u32,
        i_userdata: *mut cty::c_void,
    ) -> IM3Runtime;
}
extern "C" {
    pub fn m3_FreeRuntime(i_runtime: IM3Runtime);
}
extern "C" {
    pub fn m3_GetMemory(
        i_runtime: IM3Runtime,
        o_memorySizeInBytes: *mut u32,
        i_memoryIndex: u32,
    ) -> *mut u8;
}
extern "C" {
    pub fn m3_GetMemorySize(i_runtime: IM3Runtime) -> u32;
}
extern "C" {
    pub fn m3_GetUserData(i_runtime: IM3Runtime) -> *mut cty::c_void;
}
extern "C" {
    pub fn m3_ParseModule(
        i_environment: IM3Environment,
        o_module: *mut IM3Module,
        i_wasmBytes: *const u8,
        i_numWasmBytes: u32,
    ) -> M3Result;
}
extern "C" {
    pub fn m3_FreeModule(i_module: IM3Module);
}
extern "C" {
    pub fn m3_LoadModule(io_runtime: IM3Runtime, io_module: IM3Module) -> M3Result;
}
extern "C" {
    pub fn m3_CompileModule(io_module: IM3Module) -> M3Result;
}
extern "C" {
    pub fn m3_RunStart(i_module: IM3Module) -> M3Result;
}
pub type M3RawCall = ::core::option::Option<
    unsafe extern "C" fn(
        runtime: IM3Runtime,
        _ctx: IM3ImportContext,
        _sp: *mut u64,
        _mem: *mut cty::c_void,
    ) -> *const cty::c_void,
>;
extern "C" {
    pub fn m3_LinkRawFunction(
        io_module: IM3Module,
        i_moduleName: *const cty::c_char,
        i_functionName: *const cty::c_char,
        i_signature: *const cty::c_char,
        i_function: M3RawCall,
    ) -> M3Result;
}
extern "C" {
    pub fn m3_LinkRawFunctionEx(
        io_module: IM3Module,
        i_moduleName: *const cty::c_char,
        i_functionName: *const cty::c_char,
        i_signature: *const cty::c_char,
        i_function: M3RawCall,
        i_userdata: *const cty::c_void,
    ) -> M3Result;
}
extern "C" {
    pub fn m3_GetModuleName(i_module: IM3Module) -> *const cty::c_char;
}
extern "C" {
    pub fn m3_SetModuleName(i_module: IM3Module, name: *const cty::c_char);
}
extern "C" {
    pub fn m3_GetModuleRuntime(i_module: IM3Module) -> IM3Runtime;
}
extern "C" {
    pub fn m3_FindGlobal(io_module: IM3Module, i_globalName: *const cty::c_char) -> IM3Global;
}
extern "C" {
    pub fn m3_GetGlobal(i_global: IM3Global, o_value: IM3TaggedValue) -> M3Result;
}
extern "C" {
    pub fn m3_SetGlobal(i_global: IM3Global, i_value: IM3TaggedValue) -> M3Result;
}
extern "C" {
    pub fn m3_GetGlobalType(i_global: IM3Global) -> M3ValueType::Type;
}
extern "C" {
    pub fn m3_Yield() -> M3Result;
}
extern "C" {
    pub fn m3_FindFunction(
        o_function: *mut IM3Function,
        i_runtime: IM3Runtime,
        i_functionName: *const cty::c_char,
    ) -> M3Result;
}
extern "C" {
    pub fn m3_GetArgCount(i_function: IM3Function) -> u32;
}
extern "C" {
    pub fn m3_GetRetCount(i_function: IM3Function) -> u32;
}
extern "C" {
    pub fn m3_GetArgType(i_function: IM3Function, i_index: u32) -> M3ValueType::Type;
}
extern "C" {
    pub fn m3_GetRetType(i_function: IM3Function, i_index: u32) -> M3ValueType::Type;
}
extern "C" {
    pub fn m3_CallV(i_function: IM3Function, ...) -> M3Result;
}
extern "C" {
    pub fn m3_CallVL(i_function: IM3Function, i_args: *mut __va_list_tag) -> M3Result;
}
extern "C" {
    pub fn m3_Call(
        i_function: IM3Function,
        i_argc: u32,
        i_argptrs: *mut *const cty::c_void,
    ) -> M3Result;
}
extern "C" {
    pub fn m3_CallArgv(
        i_function: IM3Function,
        i_argc: u32,
        i_argv: *mut *const cty::c_char,
    ) -> M3Result;
}
extern "C" {
    pub fn m3_GetResultsV(i_function: IM3Function, ...) -> M3Result;
}
extern "C" {
    pub fn m3_GetResultsVL(i_function: IM3Function, o_rets: *mut __va_list_tag) -> M3Result;
}
extern "C" {
    pub fn m3_GetResults(
        i_function: IM3Function,
        i_retc: u32,
        o_retptrs: *mut *const cty::c_void,
    ) -> M3Result;
}
extern "C" {
    pub fn m3_GetErrorInfo(i_runtime: IM3Runtime, o_info: *mut M3ErrorInfo);
}
extern "C" {
    pub fn m3_ResetErrorInfo(i_runtime: IM3Runtime);
}
extern "C" {
    pub fn m3_GetFunctionName(i_function: IM3Function) -> *const cty::c_char;
}
extern "C" {
    pub fn m3_GetFunctionModule(i_function: IM3Function) -> IM3Module;
}
extern "C" {
    pub fn m3_PrintRuntimeInfo(i_runtime: IM3Runtime);
}
extern "C" {
    pub fn m3_PrintM3Info();
}
extern "C" {
    pub fn m3_PrintProfilerInfo();
}
extern "C" {
    pub fn m3_GetBacktrace(i_runtime: IM3Runtime) -> IM3BacktraceInfo;
}
pub type u64_ = u64;
pub type i64_ = i64;
pub type u32_ = u32;
pub type i32_ = i32;
pub type u16_ = u16;
pub type u8_ = u8;
pub type i8_ = i8;
pub type f64_ = f64;
pub type f32_ = f32;
pub type m3ret_t = *const cty::c_void;
pub type voidptr_t = *const cty::c_void;
pub type cstr_t = *const cty::c_char;
pub type ccstr_t = *const cty::c_char;
pub type bytes_t = *const u8_;
pub type cbytes_t = *const u8_;
pub type m3opcode_t = u16_;
pub type m3reg_t = i64_;
pub type m3slot_t = u32_;
pub type m3stack_t = *mut m3slot_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3MemoryHeader {
    pub runtime: IM3Runtime,
    pub maxStack: *mut cty::c_void,
    pub length: size_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3CodeMappingPage {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3CodePageHeader {
    pub next: *mut M3CodePage,
    pub lineIndex: u32_,
    pub numLines: u32_,
    pub sequence: u32_,
    pub usageCount: u32_,
}
extern "C" {
    pub fn m3_Abort(message: *const cty::c_char);
}
extern "C" {
    pub fn m3_Malloc(i_size: size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn m3_Realloc(
        i_ptr: *mut cty::c_void,
        i_newSize: size_t,
        i_oldSize: size_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn m3_FreeImpl(i_ptr: *mut cty::c_void);
}
extern "C" {
    pub fn m3_CopyMem(i_from: *const cty::c_void, i_size: size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn NormalizeType(o_type: *mut u8_, i_convolutedWasmType: i8_) -> M3Result;
}
extern "C" {
    pub fn IsIntType(i_wasmType: u8_) -> bool;
}
extern "C" {
    pub fn IsFpType(i_wasmType: u8_) -> bool;
}
extern "C" {
    pub fn Is64BitType(i_m3Type: u8_) -> bool;
}
extern "C" {
    pub fn SizeOfType(i_m3Type: u8_) -> u32_;
}
extern "C" {
    pub fn Read_u64(o_value: *mut u64_, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn Read_u32(o_value: *mut u32_, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn Read_f64(o_value: *mut f64_, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn Read_f32(o_value: *mut f32_, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn Read_u8(o_value: *mut u8_, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn Read_opcode(
        o_value: *mut m3opcode_t,
        io_bytes: *mut bytes_t,
        i_end: cbytes_t,
    ) -> M3Result;
}
extern "C" {
    pub fn ReadLebUnsigned(
        o_value: *mut u64_,
        i_maxNumBits: u32_,
        io_bytes: *mut bytes_t,
        i_end: cbytes_t,
    ) -> M3Result;
}
extern "C" {
    pub fn ReadLebSigned(
        o_value: *mut i64_,
        i_maxNumBits: u32_,
        io_bytes: *mut bytes_t,
        i_end: cbytes_t,
    ) -> M3Result;
}
extern "C" {
    pub fn ReadLEB_u32(o_value: *mut u32_, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn ReadLEB_u7(o_value: *mut u8_, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn ReadLEB_i7(o_value: *mut i8_, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn ReadLEB_i32(o_value: *mut i32_, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn ReadLEB_i64(o_value: *mut i64_, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn Read_utf8(o_utf8: *mut cstr_t, io_bytes: *mut bytes_t, i_end: cbytes_t) -> M3Result;
}
extern "C" {
    pub fn SPrintValue(i_value: *mut cty::c_void, i_type: u8_) -> cstr_t;
}
extern "C" {
    pub fn SPrintArg(
        o_string: *mut cty::c_char,
        i_stringBufferSize: size_t,
        i_sp: voidptr_t,
        i_type: u8_,
    ) -> size_t;
}
extern "C" {
    pub fn ReportError(
        io_runtime: IM3Runtime,
        i_module: IM3Module,
        i_function: IM3Function,
        i_errorMessage: ccstr_t,
        i_file: ccstr_t,
        i_lineNum: u32_,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct m3_wasi_context_t {
    pub exit_code: i32_,
    pub argc: u32_,
    pub argv: *mut ccstr_t,
}
extern "C" {
    pub fn m3_LinkWASI(io_module: IM3Module) -> M3Result;
}
extern "C" {
    pub fn m3_GetWasiContext() -> *mut m3_wasi_context_t;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: cty::c_uint,
    pub fp_offset: cty::c_uint,
    pub overflow_arg_area: *mut cty::c_void,
    pub reg_save_area: *mut cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M3CodePage {
    pub _address: u8,
}
